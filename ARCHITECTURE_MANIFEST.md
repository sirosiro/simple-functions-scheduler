# アーキテクチャ憲章 (Architecture Manifest)

---

## Part 1: このマニフェストの取扱説明書 (Guide)

このパートは、このマニフェストの思想、目的、そして書き方を定義するガイドです。このドキュメントを編集する際は、まずここを読んでください。

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

*   **役割:** この憲章は、プロジェクトの「北極星」です。開発者とAIが共有する高レベルな目標と、譲れない制約を定義します。これは、日々のコーディングにおける判断の拠り所となります。
*   **期待する効果:** これにより、AIは単なるコード生成を超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能になります。人間は、設計判断の背景を素早く理解し、一貫性を保った開発を継続できます。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   「高速であるべき」のような曖昧な表現ではなく、「APIのP95応答時間は100ms未満であるべき」のように、検証可能で具体的な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。例えば、「我々はスループットよりもデータ一貫性を優先する。なぜなら金融取引を扱うからだ」のように記述します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述するように促します。これにより、将来状況が変化した際に、より柔軟で適切な判断を下すことが可能になります。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいライブラリの導入、主要コンポーネントの責務変更）は、必ずこの憲章の更新とセットでレビューします。

*   **リスク:** 全体原則と、局所的な要求が衝突する。
    *   **対策:** 原則として、この憲章の記述を優先します。ただし、局所的なコード内コメントで、逸脱する明確な理由とそれが戦術的な判断であることが示されている場合に限り、限定的な逸脱を許容します。

---

## Part 2: マニフェスト本体 (Content)

このパートは、プロジェクトの進化に合わせてエンジニアが継続的に編集・追記する、生きた記録です。

### 1. 核となる原則 (Core Principles)

このプロジェクトの不変的なルールを、「なぜ」の理由付けと共に定義します。

*   **原則1: C89/C90標準への準拠と外部ライブラリ非依存**
    *   **判断:** 我々は、C89/C90 (`-ansi`) に準拠し、C標準ライブラリを含む一切の外部ライブラリに依存しない自己完結したモジュールとして開発を行う。
    *   **理由:** 特定のハードウェアやOS、コンパイラに依存しない、最大限のポータビリティを確保するため。これにより、本ライブラリはリソースが極めて制限された特殊な組み込み環境でも利用可能となる。新たに必要な標準関数（例: `memcpy`）は、この原則に従い自前で実装する。

*   **原則2: 静的メモリ管理による確定的動作の保証**
    *   **判断:** 我々は、`malloc`/`free` に代表される動的なメモリ確保を一切行わない。全てのメモリは、静的なグローバル配列や、呼び出し元が提供するバッファから確保する。
    *   **理由:** 実行時のメモリ消費量をコンパイル時に確定させ、ヒープ断片化やメモリリークのリスクを完全に排除するため。これは、長時間連続稼働が要求される組み込みシステムにおいて、システムの安定性と信頼性を保証する上で極めて重要である。

*   **原則3: 関数ポインタによるハードウェア抽象化**
    *   **判断:** 割り込み制御など、ハードウェアや実行環境に直接依存する処理は、関数ポインタの形で外部から注入する設計パターンを標準とする。
    *   **理由:** ライブラリのコアロジックとプラットフォーム依存部を明確に分離するため。これにより、ライブラリ本体を変更することなく、多様なターゲットプラットフォームへ容易に移植することが可能となる。

*   **原則4: グローバルスコープでの状態管理**
    *   **判断:** `sfs.c` のタスクリストポインタ `pTask` のように、モジュールの状態は `static` なグローバル変数で管理する。
    *   **理由:** 現状のライブラリの規模と機能において、このアプローチは実装が単純で理解しやすいため。
    *   **将来の考慮点:** より複雑な要件（例: 複数のスケジューラインスタンスの同時利用）が必要になった場合は、モジュールの状態を一つの構造体に集約し、そのポインタをユーザーが管理する「Opaque Pointer パターン」へのリファクタリングを検討する。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。

*   **2026-01-21: FIFOの実装方針: `memcpy` 対 型ごとのポインタ操作**
    *   **関連する核となる原則:** 原則1 (外部ライブラリ非依存)
    *   **決定:** FIFOコンポーネントのデータコピー処理において、汎用的な`memcpy`実装は採用せず、`char`, `short`, `long` といった基本型に特化したポインタ操作で実装する。
    *   **論理的根拠:** 汎用的なバイト単位コピーは、どのようなデータサイズにも対応できる反面、今回の「イベントキューイング」という主目的においては過剰スペックである。型を限定することで、コンパイラによる最適化が期待でき、より高速な動作を目指す。また、`void*` と `memcpy` に頼る実装よりも、型を意識したAPIの方が静的に安全である。
    *   **検討した代替案:** `memcpy` を自前実装し、任意のデータサイズをFIFOで扱えるようにする案。これは棄却された。なぜなら、第一にパフォーマンスへの懸念、第二に、本プロジェクトが意図的に「FIFO（イベント用途）」と「リングバッファ（連続データ用途）」を区別しており、FIFOに可変長データの管理責務を持たせるのはその思想に反するため。
    *   **想定される結果:** FIFOが扱えるデータ型は基本整数型に限定されるが、コードはよりシンプルかつ高速になる。メモリも各々の型に合わせて効率的に利用される。

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

このセクションは、AIがどう振る舞うべきかの指針を記述するセクションです。

*   **未知の問題への対処:**
    *   この憲章に記載されていないアーキテクチャ上の問題に直面した際、AIはプロジェクトの「核となる原則」に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰ぐこと。

*   **戦略（憲章）と戦術（コメント）の連携:**
    *   AIは、この憲章（戦略）とコード内のインテント・コメント（戦術）が一貫性を保つように支援する。コード生成やリファクタリングの提案は、常に両者と整合性が取れていなければならない。

### 4. コンポーネント設計仕様 (Component Design Specifications)

このセクションは、本マニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義するセクションです。

#### 4.1. SFS (Simple Function Scheduler) モジュール

-   **責務 (Responsibility):**
    *   固定数のタスク制御ブロック (TCB) を管理し、タスクの生成、実行、終了、変更を協調的マルチタスクモデルで提供する。
    *   タスクを優先度 `order` に基づいて実行待ちリストに登録し、その順序でディスパッチする。
    *   タスクが共有可能なワークバッファを提供し、タスク間でデータを交換できるようにする。

-   **提供するAPI (Public API):**
    *   `short SFS_initialize(void)`:
        *   責務: スケジューラの内部状態とタスク制御ブロックのプールを初期化する。
        *   戻り値: `0` (成功)。
    *   `short SFS_dispatch(void)`:
        *   責務: 現在のアクティブタスクリストを順番に実行する。各タスクは自身が制御を返却するまで実行される。
        *   戻り値: `実行されたタスクの数`。
    *   `short SFS_fork(char *name, short order, void (*entry_point)(void))`:
        *   責務: 新しいタスクを生成し、フリーリストからTCBを取得して初期化し、`order` に基づいて実行待ちリストに挿入する。
        *   `name`: タスク名。関数内でコピーして使用するため、呼び出し元は自身のポインタ管理責任を持つ。
        *   `order`: タスクの優先度。数値が小さいほど高優先度。
        *   `entry_point`: タスクのメイン処理を行う関数へのポインタ。
        *   戻り値: `True` (成功), `False` (タスク制御ブロックの割り当て失敗)。
    *   `void *SFS_work(void)`:
        *   責務: 現在実行中のタスクに割り当てられた汎用ワークバッファへのポインタを返す。
        *   戻り値: `void*` (現在のタスクの `work` バッファへのポインタ)。
    *   `void *SFS_otherWork(char *name)`:
        *   責務: 指定された名前のタスクに割り当てられた汎用ワークバッファへのポインタを返す。
        *   `name`: ワークバッファを取得したいタスクの名前。
        *   戻り値: `void*` (指定タスクの `work` バッファへのポインタ), `NULL` (タスクが見つからない場合)。
    *   `short SFS_kill(void)`:
        *   責務: 現在実行中のタスクを終了処理に移行させる。実際の削除は `SFS_dispatch` の次のサイクルで行われる。
        *   戻り値: `0` (成功)。
    *   `short SFS_change(char *name, short order, void (*entry_point)(void))`:
        *   責務: 現在実行中のタスクの名前、優先度、エントリポイントを変更する。
        *   `name`: 新しいタスク名。
        *   `order`: 新しい優先度。
        *   `entry_point`: 新しいタスクのエントリポイント。
        *   戻り値: `0` (成功)。

-   **主要なデータ構造 (Key Data Structures):**
    *   `struct SFS_tg`:
        ```c
        struct SFS_tg {
          char name[SFS_NAME_SIZE];      // タスク名 (固定長)
          unsigned short order;          // 実行優先度 (小さいほど高優先度)
          struct SFS_tg *pFront;       // 実行待ちリストの前のタスクへのポインタ (双方向リスト用)
          struct SFS_tg *pBack;        // 実行待ちリストの次のタスクへのポインタ (双方向リスト用)
          void (*pFunction)(void);       // タスクのエントリポイント関数ポインタ
          char work[SFS_WORK_SIZE];      // タスク固有の汎用ワークバッファ
        };
        ```
    *   `static struct SFS_tg SFS[BODY]`: 全タスク制御ブロックを保持する固定長配列。
    *   `static struct SFS_tg *pTask`: 実行待ちのアクティブなタスクリストのヘッドポインタ。`order` に基づいてソートされた双方向連結リスト。
    *   `static struct SFS_tg *pPool`: 利用可能なタスク制御ブロックのフリーリストのヘッドポインタ。単方向連結リスト。

-   **状態とライフサイクル (State and Lifecycle):**
    *   **TCBの状態:**
        *   `Pooled`: `pPool` リストに存在し、利用可能な状態。
        *   `Active`: `pTask` リストに存在し、実行待ちまたは実行中の状態。
        *   `Killed`: `SFS_kill` により `pFunction` が `SFS_giveup` に置き換えられた状態。`SFS_dispatch` で実行された後 `Pooled` に戻る。
    *   **スケジューラのライフサイクル:** `SFS_initialize` で初期化され、`SFS_dispatch` をループで呼び出すことでタスクが実行される。タスクは `SFS_fork` で追加され、`SFS_kill` で論理的に削除、`SFS_giveup` で物理的に削除される。

-   **重要なアルゴリズム (Key Algorithms):**
    *   **タスク登録 (`SFS_regist`):** タスクの `order` に基づくソート済み挿入。ヘッド、テール、中間への挿入を双方向リンクリストで処理。
    *   **タスク解放 (`SFS_giveup`):** 双方向リンクリストからの要素削除。ヘッド、テール、中間からの削除を処理し、フリーリスト (`pPool`) に戻す。

#### 4.2. FRCC (Free Run Clock Counter) モジュール
*   **詳細仕様:** `libs/frcc/ARCHITECTURE_MANIFEST.md` を参照してください。
    *   **概要:** ハードウェア（外部）によって周期的にインクリメントされるフリーランカウンタを管理し、正確な時間差計算機能を提供します。

#### 4.3. FIFO (First-In, First-Out)
*   **詳細仕様:** `libs/fifo/ARCHITECTURE_MANIFEST.md` を参照してください。
    *   **概要:** タスク間で使われる、固定サイズのデータ要素（イベントやメッセージ）をキューイングする機能を提供します。

#### 4.4. リングバッファライブラリ (Ring Buffer Library)
*   **詳細仕様:** `libs/ring_buffer/ARCHITECTURE_MANIFEST.md` を参照してください。
    *   **概要:** バイトストリームの効率的かつ安全な書き込み・読み出し機能を提供します。データコピー処理の外部注入をサポートします。

### 5. テストと検証 (Testing and Verification)

このプロジェクトでは、サンプルコードを機能テストおよびリファレンス実装として位置づけています。

*   **詳細仕様:** `tests/ARCHITECTURE_MANIFEST.md` を参照してください。
    *   **概要:** SFSおよび各ライブラリの単体テスト、機能テスト、使用例を管理しています。開発時はこれらのテストが常にパスする状態を維持します。