# アーキテクチャ憲章 (Architecture Manifest)

---

## Part 1: このマニフェストの取扱説明書 (Guide)

このパートには、マニフェストの思想、目的、書き方を定義するガイドを含めてください。ドキュメントの冒頭に配置し、編集者はまずここを読むように促す構成とします。

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

*   **役割:** この憲章は、プロジェクトの「北極星」です。開発者とAIが共有する高レベルな目標と、譲れない制約を定義します。これは、日々のコーディングにおける判断の拠り所となります。
*   **期待する効果:** これにより、AIは単なるコード生成を超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能になります。人間は、設計判断の背景を素早く理解し、一貫性を保った開発を継続できます。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   「高速であるべき」のような曖昧な表現ではなく、「APIのP95応答時間は100ms未満であるべき」のように、検証可能で具体的な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。例えば、「我々はスループットよりもデータ一貫性を優先する。なぜなら金融取引を扱うからだ」のように記述します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述するように促します。これにより、将来状況が変化した際に、より柔軟で適切な判断を下すことが可能になります。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいライブラリの導入、主要コンポーネントの責務変更）は、必ずこの憲章の更新とセットでレビューします。

*   **リスク:** 全体原則と、局所的な要求が衝突する。
    *   **対策:** 原則として、この憲章の記述を優先します。ただし、局所的なコード内コメントで、逸脱する明確な理由とそれが戦術的な判断であることが示されている場合に限り、限定的な逸脱を許容します。

---

## Part 2: マニフェスト本体 (Content)

このパートは、プロジェクトの進化に合わせてエンジニアが継続的に編集・追記する、生きた記録です。

### 1. 核となる原則 (Core Principles)

このプロジェクトの不変的なルールを、「なぜ」の理由付けと共に定義します。

*   **原則1: C89/C90標準への準拠と外部ライブラリ非依存**
    *   **判断:** 我々は、C89/C90 (`-ansi`) に準拠し、C標準ライブラリを含む一切の外部ライブラリに依存しない自己完結したモジュールとして開発を行う。
    *   **理由:** 特定のハードウェアやOS、コンパイラに依存しない、最大限のポータビリティを確保するため。これにより、本ライブラリはリソースが極めて制限された特殊な組み込み環境でも利用可能となる。新たに必要な標準関数（例: `memcpy`）は、この原則に従い自前で実装する。

*   **原則2: 静的メモリ管理による確定的動作の保証**
    *   **判断:** 我々は、`malloc`/`free` に代表される動的なメモリ確保を一切行わない。全てのメモリは、静的なグローバル配列や、呼び出し元が提供するバッファから確保する。
    *   **理由:** 実行時のメモリ消費量をコンパイル時に確定させ、ヒープ断片化やメモリリークのリスクを完全に排除するため。これは、長時間連続稼働が要求される組み込みシステムにおいて、システムの安定性と信頼性を保証する上で極めて重要である。

*   **原則3: 関数ポインタによるハードウェア抽象化**
    *   **判断:** 割り込み制御など、ハードウェアや実行環境に直接依存する処理は、関数ポインタの形で外部から注入する設計パターンを標準とする。
    *   **理由:** ライブラリのコアロジックとプラットフォーム依存部を明確に分離するため。これにより、ライブラリ本体を変更することなく、多様なターゲットプラットフォームへ容易に移植することが可能となる。

*   **原則4: グローバルスコープでの状態管理**
    *   **判断:** `sfs.c` のタスクリストポインタ `pTask` のように、モジュールの状態は `static` なグローバル変数で管理する。
    *   **理由:** 現状のライブラリの規模と機能において、このアプローチは実装が単純で理解しやすいため。
    *   **将来の考慮点:** より複雑な要件（例: 複数のスケジューラインスタンスの同時利用）が必要になった場合は、モジュールの状態を一つの構造体に集約し、そのポインタをユーザーが管理する「Opaque Pointer パターン」へのリファクタリングを検討する。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。

*   **2026-01-21: FIFOの実装方針: `memcpy` 対 型ごとのポインタ操作**
    *   **関連する核となる原則:** 原則1 (外部ライブラリ非依存)
    *   **決定:** FIFOコンポーネントのデータコピー処理において、汎用的な`memcpy`実装は採用せず、`char`, `short`, `long` といった基本型に特化したポインタ操作で実装する。
    *   **論理的根拠:** 汎用的なバイト単位コピーは、どのようなデータサイズにも対応できる反面、今回の「イベントキューイング」という主目的においては過剰スペックである。型を限定することで、コンパイラによる最適化が期待でき、より高速な動作を目指す。また、`void*` と `memcpy` に頼る実装よりも、型を意識したAPIの方が静的に安全である。
    *   **検討した代替案:** `memcpy` を自前実装し、任意のデータサイズをFIFOで扱えるようにする案。これは棄却された。なぜなら、第一にパフォーマンスへの懸念、第二に、本プロジェクトが意図的に「FIFO（イベント用途）」と「リングバッファ（連続データ用途）」を区別しており、FIFOに可変長データの管理責務を持たせるのはその思想に反するため。
    *   **想定される結果:** FIFOが扱えるデータ型は基本整数型に限定されるが、コードはよりシンプルかつ高速になる。メモリも各々の型に合わせて効率的に利用される。

<!--
### YYYY-MM-DD: (決定のタイトル)
*   **関連する核となる原則:** (例: 原則2: 静的メモリ管理)
*   **決定:** (我々が下した具体的な決定内容)
*   **論理的根拠:** (なぜこの決定を下したのか。背景、目的、トレードオフ)
*   **検討した代替案:** (例: 代替案A, 代B。なぜそれらを棄却したか)
*   **想定される結果:** (この決定がもたらすポジティブな影響と、許容するネガティブな影響)
-->

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

*   **未知の問題への対処:**
    *   この憲章に記載されていないアーキテクチャ上の問題に直面した際、AIはプロジェクトの「核となる原則」に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰ぐこと。

*   **戦略（憲章）と戦術（コメント）の連携:**
    *   AIは、この憲章（戦略）とコード内のインテント・コメント（戦術）が一貫性を保つように支援する。コード生成やリファクタリングの提案は、常に両者と整合性が取れていなければならない。

### 4. コンポーネント設計仕様 (Component Design Specifications)

このマニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義します。

#### 4.1. SFS (Simple Functions Scheduler)
*   **責務 (Responsibility):**
    *   協調的マルチタスク環境を提供する。タスクの登録、実行順序の管理、実行、削除のライフサイクルを管理する責務を負う。
    *   動的メモリ確保を行わず、静的に確保されたメモリプール内でのみタスクを管理することで、システムの確定的な動作を保証する。
*   **提供するAPI (Public API):** (省略)
*   **主要なデータ構造 (Key Data Structures):** (省略)
*   **状態とライフサイクル (State and Lifecycle):** (省略)
*   **重要なアルゴリズム (Key Algorithms):** (省略)

#### 4.2. FRCC (Free Run Counter)
*   **責務 (Responsibility):**
    *   システム時刻の基準となるフリーランカウンタの値を提供し、時間の経過を測定する機能を提供する。
    *   カウンタへのアクセスがアトミックに行われることを保証する責務を負う。実際の割り込み制御は外部から注入された関数に委譲する。
*   **提供するAPI (Public API):** (省略)
*   **重要なアルゴリズ (Key Algorithms):** (省略)

#### 4.3. FIFO (First-In, First-Out)
*   **責務 (Responsibility):**
    *   タスク間で使われる、固定サイズのデータ要素（イベントやメッセージ）をキューイングする責務を負う。
    *   本コンポーネントは「イベント」のような個別データを扱うことを主目的とする。計測データのような連続したストリームデータを扱うのは「リングバッファ」コンポーネントの責務とし、明確に分離する。
*   **提供するAPI (Public API):**
    *   `void FIFO_initialize(struct FIFO_cb *fifo_cb, void *buffer, unsigned int capacity, enum FIFO_ElementType type)`: FIFO制御ブロックを初期化する。
        *   `type`: このFIFOが `char`, `short`, `long` のどの型を扱うかを指定する。バッファのメモリ効率とアクセス方法は、この型に基づいて最適化される。
    *   `int FIFO_push(struct FIFO_cb *fifo_cb, const void *element)`: FIFOに1要素をプッシュする。
    *   `int FIFO_pop(struct FIFO_cb *fifo_cb, void *element)`: FIFOから1要素をポップする。
*   **主要なデータ構造 (Key Data Structures):**
    *   `enum FIFO_ElementType`: FIFOが扱うデータ型を定義する。
    *   `struct FIFO_cb`: FIFOの制御ブロック。バッファの開始/終了/読み取り/書き込み位置を、インデックスではなく `void*` ポインタで直接管理する。
*   **状態とライフサイクル (State and Lifecycle):**
    *   `FIFO_initialize` によって「空」状態で生成される。
    *   `FIFO_push` によってデータが追加され、「通常」状態または「満杯」状態に遷移する。
    *   `FIFO_pop` によってデータが取り出され、「通常」状態または「空」状態に遷移する。
*   **重要なアルゴリズム (Key Algorithms):**
    *   **型ごとのポインタアクセス:** `push`/`pop` 処理時、`type` メンバに応じて `void*` ポインタを適切な型 (`char*`, `short*`, `long*`) にキャストし、直接代入を行う。これにより `memcpy` を回避し、型に最適化されたメモリアクセスを実現する。
    *   **ポインタベースのリングバッファ管理:** バッファの読み書き位置を整数インデックスではなくポインタで直接管理する。ポインタがバッfaの終端 (`pEnd`) に達したら、始端 (`pStart`) に戻すことでリング動作を実現する。
