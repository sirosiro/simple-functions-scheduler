# アーキテクチャ憲章 (Architecture Manifest)

---

## Part 1: このマニフェストの取扱説明書 (Guide)

このパートは、このマニフェストの思想、目的、そして書き方を定義するガイドです。このドキュメントを編集する際は、まずここを読んでください。

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

*   **役割:** この憲章は、プロジェクトの「北極星」です。開発者とAIが共有する高レベルな目標と、譲れない制約を定義します。これは、日々のコーディングにおける判断の拠り所となります。
*   **期待する効果:** これにより、AIは単なるコード生成を超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能になります。人間は、設計判断の背景を素早く理解し、一貫性を保った開発を継続できます。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   「高速であるべき」のような曖昧な表現ではなく、「APIのP95応答時間は100ms未満であるべき」のように、検証可能で具体的な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。例えば、「我々はスループットよりもデータ一貫性を優先する。なぜなら金融取引を扱うからだ」のように記述します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述するように促します。これにより、将来状況が変化した際に、より柔軟で適切な判断を下すことが可能になります。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいライブラリの導入、主要コンポーネントの責務変更）は、必ずこの憲章の更新とセットでレビューします。

*   **リスク:** 全体原則と、局所的な要求が衝突する。
    *   **対策:** 原則として、この憲章の記述を優先します。ただし、局所的なコード内コメントで、逸脱する明確な理由とそれが戦術的な判断であることが示されている場合に限り、限定的な逸脱を許容します。

---

## Part 2: マニフェスト本体 (Content)

このパートは、プロジェクトの進化に合わせてエンジニアが継続的に編集・追記する、生きた記録です。

### 1. 核となる原則 (Core Principles)

このプロジェクトの不変的なルールを、「なぜ」の理由付けと共に定義します。

*   **原則1: C89/C90標準への準拠と外部ライブラリ非依存**
    *   **判断:** 我々は、C89/C90 (`-ansi`) に準拠し、C標準ライブラリを含む一切の外部ライブラリに依存しない自己完結したモジュールとして開発を行う。
    *   **理由:** 特定のハードウェアやOS、コンパイラに依存しない、最大限のポータビリティを確保するため。これにより、本ライブラリはリソースが極めて制限された特殊な組み込み環境でも利用可能となる。新たに必要な標準関数（例: `memcpy`）は、この原則に従い自前で実装する。

*   **原則2: 静的メモリ管理による確定的動作の保証**
    *   **判断:** 我々は、`malloc`/`free` に代表される動的なメモリ確保を一切行わない。全てのメモリは、静的なグローバル配列や、呼び出し元が提供するバッファから確保する。
    *   **理由:** 実行時のメモリ消費量をコンパイル時に確定させ、ヒープ断片化やメモリリークのリスクを完全に排除するため。これは、長時間連続稼働が要求される組み込みシステムにおいて、システムの安定性と信頼性を保証する上で極めて重要である。

*   **原則3: 関数ポインタによるハードウェア抽象化**
    *   **判断:** 割り込み制御など、ハードウェアや実行環境に直接依存する処理は、関数ポインタの形で外部から注入する設計パターンを標準とする。
    *   **理由:** ライブラリのコアロジックとプラットフォーム依存部を明確に分離するため。これにより、ライブラリ本体を変更することなく、多様なターゲットプラットフォームへ容易に移植することが可能となる。

*   **原則4: グローバルスコープでの状態管理**
    *   **判断:** `sfs.c` のタスクリストポインタ `pTask` のように、モジュールの状態は `static` なグローバル変数で管理する。
    *   **理由:** 現状のライブラリの規模と機能において、このアプローチは実装が単純で理解しやすいため。
    *   **将来の考慮点:** より複雑な要件（例: 複数のスケジューラインスタンスの同時利用）が必要になった場合は、モジュールの状態を一つの構造体に集約し、そのポインタをユーザーが管理する「Opaque Pointer パターン」へのリファクタリングを検討する。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残します。

*   **2026-01-21: FIFOの実装方針: `memcpy` 対 型ごとのポインタ操作**
    *   **関連する核となる原則:** 原則1 (外部ライブラリ非依存)
    *   **決定:** FIFOコンポーネントのデータコピー処理において、汎用的な`memcpy`実装は採用せず、`char`, `short`, `long` といった基本型に特化したポインタ操作で実装する。
    *   **論理的根拠:** 汎用的なバイト単位コピーは、どのようなデータサイズにも対応できる反面、今回の「イベントキューイング」という主目的においては過剰スペックである。型を限定することで、コンパイラによる最適化が期待でき、より高速な動作を目指す。また、`void*` と `memcpy` に頼る実装よりも、型を意識したAPIの方が静的に安全である。
    *   **検討した代替案:** `memcpy` を自前実装し、任意のデータサイズをFIFOで扱えるようにする案。これは棄却された。なぜなら、第一にパフォーマンスへの懸念、第二に、本プロジェクトが意図的に「FIFO（イベント用途）」と「リングバッファ（連続データ用途）」を区別しており、FIFOに可変長データの管理責務を持たせるのはその思想に反するため。
    *   **想定される結果:** FIFOが扱えるデータ型は基本整数型に限定されるが、コードはよりシンプルかつ高速になる。メモリも各々の型に合わせて効率的に利用される。

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

このセクションは、AIがどう振る舞うべきかの指針を記述するセクションです。

*   **未知の問題への対処:**
    *   この憲章に記載されていないアーキテクチャ上の問題に直面した際、AIはプロジェクトの「核となる原則」に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰ぐこと。

*   **戦略（憲章）と戦術（コメント）の連携:**
    *   AIは、この憲章（戦略）とコード内のインテント・コメント（戦術）が一貫性を保つように支援する。コード生成やリファクタリングの提案は、常に両者と整合性が取れていなければならない。

### 4. コンポーネント設計仕様 (Component Design Specifications)

このセクションは、本マニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義するセクションです。

#### 4.1. SFS (Simple Function Scheduler) モジュール

-   **責務 (Responsibility):**
    *   固定数のタスク制御ブロック (TCB) を管理し、タスクの生成、実行、終了、変更を協調的マルチタスクモデルで提供する。
    *   タスクを優先度 `order` に基づいて実行待ちリストに登録し、その順序でディスパッチする。
    *   タスクが共有可能なワークバッファを提供し、タスク間でデータを交換できるようにする。

-   **提供するAPI (Public API):**
    *   `short SFS_initialize(void)`:
        *   責務: スケジューラの内部状態とタスク制御ブロックのプールを初期化する。
        *   戻り値: `0` (成功)。
    *   `short SFS_dispatch(void)`:
        *   責務: 現在のアクティブタスクリストを順番に実行する。各タスクは自身が制御を返却するまで実行される。
        *   戻り値: `実行されたタスクの数`。
    *   `short SFS_fork(char *name, short order, void (*entry_point)(void))`:
        *   責務: 新しいタスクを生成し、フリーリストからTCBを取得して初期化し、`order` に基づいて実行待ちリストに挿入する。
        *   `name`: タスク名。関数内でコピーして使用するため、呼び出し元は自身のポインタ管理責任を持つ。
        *   `order`: タスクの優先度。数値が小さいほど高優先度。
        *   `entry_point`: タスクのメイン処理を行う関数へのポインタ。
        *   戻り値: `True` (成功), `False` (タスク制御ブロックの割り当て失敗)。
    *   `void *SFS_work(void)`:
        *   責務: 現在実行中のタスクに割り当てられた汎用ワークバッファへのポインタを返す。
        *   戻り値: `void*` (現在のタスクの `work` バッファへのポインタ)。
    *   `void *SFS_otherWork(char *name)`:
        *   責務: 指定された名前のタスクに割り当てられた汎用ワークバッファへのポインタを返す。
        *   `name`: ワークバッファを取得したいタスクの名前。
        *   戻り値: `void*` (指定タスクの `work` バッファへのポインタ), `NULL` (タスクが見つからない場合)。
    *   `short SFS_kill(void)`:
        *   責務: 現在実行中のタスクを終了処理に移行させる。実際の削除は `SFS_dispatch` の次のサイクルで行われる。
        *   戻り値: `0` (成功)。
    *   `short SFS_change(char *name, short order, void (*entry_point)(void))`:
        *   責務: 現在実行中のタスクの名前、優先度、エントリポイントを変更する。
        *   `name`: 新しいタスク名。
        *   `order`: 新しい優先度。
        *   `entry_point`: 新しいタスクのエントリポイント。
        *   戻り値: `0` (成功)。

-   **主要なデータ構造 (Key Data Structures):**
    *   `struct SFS_tg`:
        ```c
        struct SFS_tg {
          char name[SFS_NAME_SIZE];      // タスク名 (固定長)
          unsigned short order;          // 実行優先度 (小さいほど高優先度)
          struct SFS_tg *pFront;       // 実行待ちリストの前のタスクへのポインタ (双方向リスト用)
          struct SFS_tg *pBack;        // 実行待ちリストの次のタスクへのポインタ (双方向リスト用)
          void (*pFunction)(void);       // タスクのエントリポイント関数ポインタ
          char work[SFS_WORK_SIZE];      // タスク固有の汎用ワークバッファ
        };
        ```
    *   `static struct SFS_tg SFS[BODY]`: 全タスク制御ブロックを保持する固定長配列。
    *   `static struct SFS_tg *pTask`: 実行待ちのアクティブなタスクリストのヘッドポインタ。`order` に基づいてソートされた双方向連結リスト。
    *   `static struct SFS_tg *pPool`: 利用可能なタスク制御ブロックのフリーリストのヘッドポインタ。単方向連結リスト。

-   **状態とライフサイクル (State and Lifecycle):**
    *   **TCBの状態:**
        *   `Pooled`: `pPool` リストに存在し、利用可能な状態。
        *   `Active`: `pTask` リストに存在し、実行待ちまたは実行中の状態。
        *   `Killed`: `SFS_kill` により `pFunction` が `SFS_giveup` に置き換えられた状態。`SFS_dispatch` で実行された後 `Pooled` に戻る。
    *   **スケジューラのライフサイクル:** `SFS_initialize` で初期化され、`SFS_dispatch` をループで呼び出すことでタスクが実行される。タスクは `SFS_fork` で追加され、`SFS_kill` で論理的に削除、`SFS_giveup` で物理的に削除される。

-   **重要なアルゴリズム (Key Algorithms):**
    *   **タスク登録 (`SFS_regist`):** タスクの `order` に基づくソート済み挿入。ヘッド、テール、中間への挿入を双方向リンクリストで処理。
    *   **タスク解放 (`SFS_giveup`):** 双方向リンクリストからの要素削除。ヘッド、テール、中間からの削除を処理し、フリーリスト (`pPool`) に戻す。

#### 4.2. FRCC (Free Run Clock Counter) モジュール

-   **責務 (Responsibility):**
    *   ハードウェア（外部）によって周期的にインクリメントされるフリーランカウンタ（8ビット版と32ビット版）を提供する。
    *   カウンタのロールオーバーを考慮した正確な時間差計算機能を提供する。
    *   フリーランカウンタへの割り込み安全なアクセスを保証する。
    *   ワンショットまたは繰り返し可能な時間経過チェック機能を提供する。

-   **提供するAPI (Public API):**
    *   `unsigned char GetFreeRunGapMini(unsigned char vPastCount)`:
        *   責務: 8ビットフリーランカウンタ `gFreeRunCounterMini` と過去の値 `vPastCount` との間の時間差を計算する。カウンタのロールオーバーを考慮する。
        *   `vPastCount`: 過去のカウンタ値。
        *   戻り値: `unsigned char` (経過時間)。
    *   `void FRCInterrupt(void (*di)(void), void (*ei)(void))`:
        *   責務: フリーランカウンタへの原子的なアクセスを保証するために使用される、割り込み禁止/許可関数を登録する。
        *   `di`: 割り込み禁止関数へのポインタ。
        *   `ei`: 割り込み許可関数へのポインタ。
    *   `unsigned long GetFreeRunCounter(void)`:
        *   責務: 現在の32ビットフリーランカウンタ `gFreeRunCounter` の値を割り込み安全に取得する。
        *   戻り値: `unsigned long` (現在のカウンタ値)。
    *   `unsigned long GetFreeRunGap(unsigned long vFarstCount, unsigned long vSecondCount)`:
        *   責務: 2つの32ビットカウンタ値間の時間差を計算する。カウンタのロールオーバーを考慮する。
        *   `vFarstCount`: 開始カウンタ値。
        *   `vSecondCount`: 終了カウンタ値。
        *   戻り値: `unsigned long` (経過時間)。
    *   `void FRCGapCheckStart(FRC *vGapChk, unsigned long vStopGap)`:
        *   責務: 時間経過チェック用の `FRC` 構造体を初期化する。現在のカウンタ値を `StartPoint` として記録し、目標経過時間 `vStopGap` を設定する。
        *   `vGapChk`: 初期化する `FRC` 構造体へのポインタ。
        *   `vStopGap`: チェックする時間間隔。
    *   `unsigned long FRCGapCheck(FRC *vGapChk)`:
        *   責務: `FRCGapCheckStart` で設定された時間間隔が経過したかをチェックする。
        *   `vGapChk`: チェックする `FRC` 構造体へのポインタ。
        *   戻り値: `0` (時間経過済み), `それ以外の値` (残り時間)。
    *   `void FRCGapCheckStop(FRC *vGapChk)`:
        *   責務: `FRC` 構造体の時間経過チェックを停止し、無効化する。
        *   `vGapChk`: 停止する `FRC` 構造体へのポインタ。

-   **主要なデータ構造 (Key Data Structures):**
    *   `unsigned char gFreeRunCounterMini`: 8ビットフリーランカウンタ（グローバル変数）。
    *   `unsigned long gFreeRunCounter`: 32ビットフリーランカウンタ（グローバル変数）。
    *   `struct FRCGapChk_tg`:
        ```c
        typedef struct FRCGapChk_tg {
          char OneShot;          // 0: 経過済み, 1: 監視中, -1: 未使用/停止
          unsigned long StartPoint;   // 測定開始時のFreeRunCounter値
          unsigned long StopGap;      // 監視する時間間隔
        }FRC;
        ```
    *   `static void (*_di)(void)`: 割り込み禁止関数への内部ポインタ。
    *   `static void (*_ei)(void)`: 割り込み許可関数への内部ポインタ。

-   **状態とライフサイクル (State and Lifecycle):**
    *   `FRC` 構造体の `OneShot` メンバにより、タイマーの状態が管理される。
    *   `OneShot = 1`: 監視中。
    *   `OneShot = 0`: 時間経過済み（ワンショット）。
    *   `OneShot = -1`: 未使用または停止状態。

-   **重要なアルゴリズム (Key Algorithms):**
    *   **カウンタロールオーバー対応の時間差計算:**
        *   `if (iNowCount >= vPastCount) { return iNowCount - vPastCount; } else { return ((型)-1)-vPastCount+iNowCount; }`
        *   これにより、カウンタが最大値から0にロールオーバーした場合でも正確な時間差を計算できる。
    *   **原子的なカウンタ読み出し:** 登録された割り込み禁止/許可関数 (`_di`, `_ei`) を利用して、グローバルカウンタの読み出し中に割り込みが発生しないことを保証する。

#### 4.3. FIFO (First-In, First-Out)
*   **責務 (Responsibility):**
    *   タスク間で使われる、固定サイズのデータ要素（イベントやメッセージ）をキューイングする責務を負う。
    *   本コンポーネントは「イベント」のような個別データを扱うことを主目的とする。計測データのような連続したストリームデータを扱うのは「リングバッファ」コンポーネントの責務とし、明確に分離する。
*   **提供するAPI (Public API):**
    *   `void FIFO_initialize(struct FIFO_cb *fifo_cb, void *buffer, unsigned int capacity, enum FIFO_ElementType type)`: FIFO制御ブロックを初期化する。
        *   `type`: このFIFOが `char`, `short`, `long` のどの型を扱うかを指定する。バッファのメモリ効率とアクセス方法は、この型に基づいて最適化される。
    *   `int FIFO_push(struct FIFO_cb *fifo_cb, const void *element)`: FIFOに1要素をプッシュする。
    *   `int FIFO_pop(struct FIFO_cb *fifo_cb, void *element)`: FIFOから1要素をポップする。
*   **主要なデータ構造 (Key Data Structures):**
    *   `enum FIFO_ElementType`: FIFOが扱うデータ型を定義する。
    *   `struct FIFO_cb`: FIFOの制御ブロック。バッファの開始/終了/読み取り/書き込み位置を、インデックスではなく `void*` ポインタで直接管理する。
*   **状態とライフサイクル (State and Lifecycle):**
    *   `FIFO_initialize` によって「空」状態で生成される。
    *   `FIFO_push` によってデータが追加され、「通常」状態または「満杯」状態に遷移する。
    *   `FIFO_pop` によってデータが取り出され、「通常」状態または「空」状態に遷移する。
*   **重要なアルゴリズム (Key Algorithms):**
    *   **型ごとのポインタアクセス:** `push`/`pop` 処理時、`type` メンバに応じて `void*` ポインタを適切な型 (`char*`, `short*`, `long*`) にキャストし、直接代入を行う。これにより `memcpy` を回避し、型に最適化されたメモリアクセスを実現する。
    *   **ポインタベースのリングバッファ管理:** バッファの読み書き位置を整数インデックスではなくポインタで直接管理する。ポインタがバッファの終端 (`pEnd`) に達したら、始端 (`pStart`) に戻すことでリング動作を実現する。

#### 4.4. リングバッファライブラリ (Ring Buffer Library)

- **責務 (Responsibility):**
    - 固定サイズのメモリ領域をリングバッファとして管理し、バイトストリームの効率的かつ安全な書き込み・読み出し機能を提供する。
    - データコピー処理（読み書き）を外部から注入（Dependency Injection）可能にすることで、ハードウェア（DMA等）への最適化を可能にする。注入されない場合は、自前実装の標準的なメモリコピー機能を提供する。
    - 割り込みコンテキストと通常タスクコンテキストの両方から安全に呼び出せる（リエントラントな）関数設計を目指す。ただし、複数タスク/割り込みからの同時アクセスにおける排他制御は、ライブラリの利用者側の責任範囲とする。

- **提供するAPI (Public API):**
    - `typedef void (*rb_copy_func_t)(void* dest, const void* src, size_t len);`
    - `rb_bool rb_init(rb_handle_t handle, void* buffer, rb_size_t size, rb_bool overwrite_on_full, rb_copy_func_t read_func, rb_copy_func_t write_func)`:
        - **責務:** 提供されたメモリ領域(`buffer`)とサイズ(`size`)を使い、提供されたハンドル(`handle`)が指す構造体を初期化する。
        - `handle`: 初期化対象の `ring_buffer_t` 構造体へのポインタ。
        - `buffer`: リングバッファとして使用するメモリ領域へのポインタ。このポインタの管理責任は呼び出し元にある。
        - `size`: バッファのサイズ（バイト単位）。
        - `overwrite_on_full`: `RB_TRUE`の場合、バッファが満杯の時に古いデータを上書きする。`RB_FALSE`の場合は書き込みを失敗させる。
        - `read_func`, `write_func`: データコピー用の関数ポインタ。`NULL`が指定された場合、ライブラリ内部のデフォルト実装が使用される。
        - **戻り値:** 初期化に成功した場合は `RB_TRUE`、失敗した場合は `RB_FALSE` を返す。

    - `size_t rb_write(rb_handle_t handle, const void* data, size_t length)`:
        - **責務:** `init`時に指定された`write_func`またはデフォルト実装を使い、指定されたデータをリングバッファに書き込む。
        - **戻り値:** 実際に書き込めたバイト数を返す。バッファが満杯で書き込めなかった場合、`overwrite_on_full`が`false`なら0を返す。`overwrite_on_full`が`true`の場合は、要求された`length`を返す（古いデータは上書きされる）。

    - `size_t rb_read(rb_handle_t handle, void* buffer, size_t length)`:
        - **責務:** `init`時に指定された`read_func`またはデフォルト実装を使い、リングバッファからデータを読み出し、指定された`buffer`に格納する。読み出されたデータはバッファから削除される。
        - **戻り値:** 実際に読み出せたバイト数を返す。

    - `size_t rb_peek(rb_handle_t handle, void* buffer, size_t length)`:
        - **責務:** リングバッファからデータを読み出すが、バッファからは削除しない（読み出し位置は変更されない）。データコピーには`init`時に指定された`read_func`またはデフォルト実装が使われる。
        - **戻り値:** 実際に読み出せた（覗き見できた）バイト数を返す。

    - `size_t rb_get_free_space(rb_handle_t handle)`:
        - **責務:** バッファの空き容量をバイト単位で返す。
        - **戻り値:** 空きバイト数。

    - `size_t rb_get_used_space(rb_handle_t handle)`:
        - **責務:** バッファ内で使用されているデータ量をバイト単位で返す。
        - **戻り値:** 使用中のバイト数。

- **主要なデータ構造 (Key Data Structures):**
    - `ring_buffer_t` (ハンドルとして利用者に返される構造体):
        - `uint8_t* buffer`: ユーザーから提供されたバッファ領域へのポインタ。
        - `size_t size`: バッファの総サイズ。
        - `size_t head`: 書き込み位置（次に書き込むべきインデックス）。
        - `size_t tail`: 読み出し位置（次に読み出すべきインデックス）。
        - `bool is_full`: バッファが満杯かどうかを示すフラグ (`head == tail` の状態が空か満杯かを区別するために使用)。
        - `bool overwrite_on_full`: 満杯時の上書き許可フラグ。
        - `rb_copy_func_t read_from_ring`: 読み出し時に使用するデータコピー関数。
        - `rb_copy_func_t write_to_ring`: 書き込み時に使用するデータコピー関数。

- **状態とライフサイクル (State and Lifecycle):**
    - **Uninitialized:** `rb_init`が呼び出される前の状態。
    - **Empty:** バッファにデータがない状態 (`head == tail` かつ `is_full == false`)。
    - **Normal:** データが一部入っている状態。
    - **Full:** バッファが満杯の状態 (`head == tail` かつ `is_full == true`)。

- **重要なアルゴリズム (Key Algorithms):**
    - **データコピー:** `read_from_ring` / `write_to_ring` の関数ポインタ経由で実処理を呼び出す。ポインタが`NULL`の場合は、自前実装のバイト単位ループによるコピー処理を呼び出す。
    - **インデックスのラップアラウンド:** `head`および`tail`ポインタは、バッファの終端に達した場合、モジュロ演算（`% size`）または同等の比較処理によって0に戻る。パフォーマンスを重視し、`if (index >= size) index = 0;` のような分岐を基本とする。
    - **空き/使用容量の計算:** `head`と`tail`の位置関係から計算する。`head >= tail`の場合と`head < tail`（ラップアラウンド発生後）の場合で計算方法が異なる。
    - **上書き処理 (`overwrite_on_full == true`):** 書き込み要求時にバッファが満杯だった場合、書き込むデータ長に応じて`tail`（読み出しポインタ）も進めることで、古いデータを捨てる。