# FRCC ライブラリ アーキテクチャ憲章 (Architecture Manifest)

---

## Part 1: このマニフェストの取扱説明書 (Guide)

このパートは、このマニフェストの思想、目的、そして書き方を定義するガイドです。このドキュメントを編集する際は、まずここを読んでください。

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

*   **役割:** この憲章は、プロジェクトの「北極星」です。開発者とAIが共有する高レベルな目標と、譲れない制約を定義します。これは、日々のコーディングにおける判断の拠り所となります。
*   **期待する効果:** これにより、AIは単なるコード生成を超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能になります。人間は、設計判断の背景を素早く理解し、一貫性を保った開発を継続できます。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   「高速であるべき」のような曖昧な表現ではなく、「APIのP95応答時間は100ms未満であるべき」のように、検証可能で具体的な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。例えば、「我々はスループットよりもデータ一貫性を優先する。なぜなら金融取引を扱うからだ」のように記述します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述するように促します。これにより、将来状況が変化した際に、より柔軟で適切な判断を下すことが可能になります。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいライブラリの導入、主要コンポーネントの責務変更）は、必ずこの憲章の更新とセットでレビューします。

*   **リスク:** 全体原則と、局所的な要求が衝突する。
    *   **対策:** 原則として、この憲章の記述を優先します。ただし、局所的なコード内コメントで、逸脱する明確な理由とそれが戦術的な判断であることが示されている場合に限り、限定的な逸脱を許容します。

---

## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

本ライブラリ固有の原則を定義します。ルートの原則にも準拠します。

*   **原則1: 割り込み安全性とハードウェア抽象化**
    *   **判断:** クリティカルセクション（カウンタ読み出し時）の保護は、外部から注入された関数ポインタ（`di`, `ei`）を用いて行う。
    *   **理由:** 特定のマイコンやOSの割り込み制御機構に依存せず、ポータビリティを確保するため。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

該当なし (N/A)

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

このセクションは、AIがどう振る舞うべきかの指針を記述するセクションです。

*   **未知の問題への対処:**
    *   この憲章に記載されていないアーキテクチャ上の問題に直面した際、AIはプロジェクトの「核となる原則」に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰ぐこと。

*   **戦略（憲章）と戦術（コメント）の連携:**
    *   AIは、この憲章（戦略）とコード内のインテント・コメント（戦術）が一貫性を保つように支援する。コード生成やリファクタリングの提案は、常に両者と整合性が取れていなければならない。

### 4. コンポーネント設計仕様 (Component Design Specifications)

#### 4.1. FRCC (Free Run Clock Counter) モジュール

-   **責務 (Responsibility):**
    *   ハードウェア（外部）によって周期的にインクリメントされるフリーランカウンタ（8ビット版と32ビット版）を提供する。
    *   カウンタのロールオーバーを考慮した正確な時間差計算機能を提供する。
    *   フリーランカウンタへの割り込み安全なアクセスを保証する。
    *   ワンショットまたは繰り返し可能な時間経過チェック機能を提供する。

-   **提供するAPI (Public API):**
    *   `unsigned char GetFreeRunGapMini(unsigned char vPastCount)`:
        *   責務: 8ビットフリーランカウンタ `gFreeRunCounterMini` と過去の値 `vPastCount` との間の時間差を計算する。カウンタのロールオーバーを考慮する。
        *   `vPastCount`: 過去のカウンタ値。
        *   戻り値: `unsigned char` (経過時間)。
    *   `void FRCInterrupt(void (*di)(void), void (*ei)(void))`:
        *   責務: フリーランカウンタへの原子的なアクセスを保証するために使用される、割り込み禁止/許可関数を登録する。
        *   `di`: 割り込み禁止関数へのポインタ。
        *   `ei`: 割り込み許可関数へのポインタ。
    *   `unsigned long GetFreeRunCounter(void)`:
        *   責務: 現在の32ビットフリーランカウンタ `gFreeRunCounter` の値を割り込み安全に取得する。
        *   戻り値: `unsigned long` (現在のカウンタ値)。
    *   `unsigned long GetFreeRunGap(unsigned long vFarstCount, unsigned long vSecondCount)`:
        *   責務: 2つの32ビットカウンタ値間の時間差を計算する。カウンタのロールオーバーを考慮する。
        *   `vFarstCount`: 開始カウンタ値。
        *   `vSecondCount`: 終了カウンタ値。
        *   戻り値: `unsigned long` (経過時間)。
    *   `void FRCGapCheckStart(FRC *vGapChk, unsigned long vStopGap)`:
        *   責務: 時間経過チェック用の `FRC` 構造体を初期化する。現在のカウンタ値を `StartPoint` として記録し、目標経過時間 `vStopGap` を設定する。
        *   `vGapChk`: 初期化する `FRC` 構造体へのポインタ。
        *   `vStopGap`: チェックする時間間隔。
    *   `unsigned long FRCGapCheck(FRC *vGapChk)`:
        *   責務: `FRCGapCheckStart` で設定された時間間隔が経過したかをチェックする。
        *   `vGapChk`: チェックする `FRC` 構造体へのポインタ。
        *   戻り値: `0` (時間経過済み), `それ以外の値` (残り時間)。
    *   `void FRCGapCheckStop(FRC *vGapChk)`:
        *   責務: `FRC` 構造体の時間経過チェックを停止し、無効化する。
        *   `vGapChk`: 停止する `FRC` 構造体へのポインタ。

-   **主要なデータ構造 (Key Data Structures):**
    *   `unsigned char gFreeRunCounterMini`: 8ビットフリーランカウンタ（グローバル変数）。
    *   `unsigned long gFreeRunCounter`: 32ビットフリーランカウンタ（グローバル変数）。
    *   `struct FRCGapChk_tg`:
        ```c
        typedef struct FRCGapChk_tg {
          char OneShot;          // 0: 経過済み, 1: 監視中, -1: 未使用/停止
          unsigned long StartPoint;   // 測定開始時のFreeRunCounter値
          unsigned long StopGap;      // 監視する時間間隔
        }FRC;
        ```
    *   `static void (*_di)(void)`: 割り込み禁止関数への内部ポインタ。
    *   `static void (*_ei)(void)`: 割り込み許可関数への内部ポインタ。

-   **状態とライフサイクル (State and Lifecycle):**
    *   `FRC` 構造体の `OneShot` メンバにより、タイマーの状態が管理される。
    *   `OneShot = 1`: 監視中。
    *   `OneShot = 0`: 時間経過済み（ワンショット）。
    *   `OneShot = -1`: 未使用または停止状態。

-   **重要なアルゴリズム (Key Algorithms):**
    *   **カウンタロールオーバー対応の時間差計算:**
        *   `if (iNowCount >= vPastCount) { return iNowCount - vPastCount; } else { return ((型)-1)-vPastCount+iNowCount; }`
        *   これにより、カウンタが最大値から0にロールオーバーした場合でも正確な時間差を計算できる。
    *   **原子的なカウンタ読み出し:** 登録された割り込み禁止/許可関数 (`_di`, `_ei`) を利用して、グローバルカウンタの読み出し中に割り込みが発生しないことを保証する。

### 5. テストと検証 (Testing and Verification)

該当なし (N/A)