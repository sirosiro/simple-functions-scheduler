# Matrix State Machine ライブラリ アーキテクチャ憲章 (Architecture Manifest)

---

## Part 1: このマニフェストの取扱説明書 (Guide)

このパートは、このマニフェストの思想、目的、そして書き方を定義するガイドです。このドキュメントを編集する際は、まずここを読んでください。

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

*   **役割:** この憲章は、プロジェクトの「北極星」です。開発者とAIが共有する高レベルな目標と、譲れない制約を定義します。これは、日々のコーディングにおける判断の拠り所となります。
*   **期待する効果:** これにより、AIは単なるコード生成を超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能になります。人間は、設計判断の背景を素早く理解し、一貫性を保った開発を継続できます。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   「高速であるべき」のような曖昧な表現ではなく、「APIのP95応答時間は100ms未満であるべき」のように、検証可能で具体的な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。例えば、「我々はスループットよりもデータ一貫性を優先する。なぜなら金融取引を扱うからだ」のように記述します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述するように促します。これにより、将来状況が変化した際に、より柔軟で適切な判断を下すことが可能になります。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいライブラリの導入、主要コンポーネントの責務変更）は、必ずこの憲章の更新とセットでレビューします。

*   **リスク:** 全体原則と、局所的な要求が衝突する。
    *   **対策:** 原則として、この憲章の記述を優先します。ただし、局所的なコード内コメントで、逸脱する明確な理由とそれが戦術的な判断であることが示されている場合に限り、限定的な逸脱を許容します。

---

## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

本ライブラリ固有の原則を定義します。ルートの原則にも準拠します。

*   **原則1: 3次元マトリクスによる遷移定義**
    *   **判断:** 状態遷移の定義は「モード(Mode)」「状態(State)」「イベント(Event)」を軸とする3次元のマトリクス構造を基本とする。
    *   **理由:** `if`や`switch`による複雑な条件分岐を排除し、参照コストが常にO(1)となる決定論的な性能を保証するため。また、モード毎にロジックを完全に分離することで、可読性と保守性を高める。

*   **原則2: ログ機能の外部注入 (Dependency Injection)**
    *   **判断:** 状態遷移のログを記録する処理は、関数ポインタとして外部から注入する設計とする。
    *   **理由:** ライブラリ本体はロギングの責務を持たず、利用者が`printf`、`ring_buffer`、あるいは何もしない、といった具体的な実装を自由に選択できるようにするため。これはSFS全体のハードウェア抽象化の原則に合致する。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

該当なし (N/A)

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

このセクションは、AIがどう振る舞うべきかの指針を記述するセクションです。

*   **未知の問題への対処:**
    *   この憲章に記載されていないアーキテクチャ上の問題に直面した際、AIはプロジェクトの「核となる原則」に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰ぐこと。

*   **戦略（憲章）と戦術（コメント）の連携:**
    *   AIは、この憲章（戦略）とコード内のインテント・コメント（戦術）が一貫性を保つように支援する。コード生成やリファクタリングの提案は、常に両者と整合性が取れていなければならない。

### 4. コンポーネント設計仕様 (Component Design Specifications)

#### 4.1. Matrix State Machine ライブラリ

-   **責務 (Responsibility):**
    *   3次元マトリクスで定義された状態遷移テーブルに基づき、システムの「モード」「状態」を管理する。
    *   外部から「イベント」を受け取り、現在のモードと状態に応じて適切なアクション関数を実行し、次の状態へ遷移する。
    *   すべての状態遷移（モード、旧状態、イベント、新状態）の情報を、外部から注入されたログ関数に渡す。

-   **提供するAPI (Public API):**
    *   `void SM_init(SM_Handle_t *handle, ...)`: ステートマシンハンドルを初期化する。遷移テーブルやログ関数もここで設定する。
    *   `void SM_dispatch(SM_Handle_t *handle, uint8_t event, void *event_data)`: イベントを投入し、状態遷移を実行させる。
    *   `void SM_setMode(SM_Handle_t *handle, uint8_t new_mode)`: ステートマシンのモードを外部から強制的に変更する。
    *   `uint8_t SM_getCurrentState(SM_Handle_t *handle)`: 現在の状態を取得する。
    - `uint8_t SM_getCurrentMode(SM_Handle_t *handle)`: 現在のモードを取得する。

-   **主要なデータ構造 (Key Data Structures):**
    *   `sm_config.h` (ユーザー定義):
        - `Modes`, `States`, `Events` の列挙型
        - `MAX_MODES`, `MAX_STATES`, `MAX_EVENTS` のマクロ
    *   `state_machine.h` (ライブラリ定義):
        ```c
        // アクション関数のポインタ型
        typedef void (*SM_Action_t)(void *context, void *event_data);

        // 遷移テーブルの1要素
        typedef struct {
            uint8_t next_state;
            SM_Action_t action;
        } SM_Transition_t;

        // ログ記録用のコールバック関数型
        typedef void (*SM_Log_Func_t)(uint8_t mode, uint8_t old_state, uint8_t event, uint8_t new_state);

        // ステートマシン・ハンドル
        typedef struct {
            uint8_t current_mode;
            uint8_t current_state;
            const SM_Transition_t *transition_table; // 3次元配列へのポインタ
            SM_Log_Func_t log_func;
            void *context; // アクション関数に渡すユーザーデータ
        } SM_Handle_t;
        ```

-   **状態とライフサイクル (State and Lifecycle):**
    *   `SM_init` によって初期モード・初期状態が設定され、「待機」状態となる。
    *   `SM_dispatch` が呼び出されるたびに、イベントに基づき「遷移中」状態を経て、次の「待機」状態へ移行する。
    *   `SM_setMode` によって、いつでもモードが変更される可能性がある。

-   **重要なアルゴリズム (Key Algorithms):**
    *   **3次元マトリクスアクセス:**
        - `SM_dispatch` 内で、`handle->transition_table` を `[mode][state][event]` のインデックスで直接参照する。
        - 高速化のため、インデックス計算は `(mode * MAX_STATES * MAX_EVENTS) + (state * MAX_EVENTS) + event` のようなポインタ演算で行う。
    *   **ログ注入:**
        - 状態遷移が確定した後、`handle->log_func` が `NULL` でないことを確認し、引数 (mode, old_state, event, new_state) を渡して呼び出す。

### 5. テストと検証 (Testing and Verification)

- `tests/sample_sm01.c` (仮):
    - 基本的な状態遷移、アクション関数の実行、ログ出力が正しく行われることを検証する。
    - 2つのモードを持ち、モード切替によって同じイベントでも異なる動作をすることを検証する。
