# リングバッファ ライブラリ アーキテクチャ憲章 (Architecture Manifest)

---

## Part 1: このマニフェストの取扱説明書 (Guide)

このパートは、このマニフェストの思想、目的、そして書き方を定義するガイドです。このドキュメントを編集する際は、まずここを読んでください。

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

*   **役割:** この憲章は、プロジェクトの「北極星」です。開発者とAIが共有する高レベルな目標と、譲れない制約を定義します。これは、日々のコーディングにおける判断の拠り所となります。
*   **期待する効果:** これにより、AIは単なるコード生成を超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能になります。人間は、設計判断の背景を素早く理解し、一貫性を保った開発を継続できます。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   「高速であるべき」のような曖昧な表現ではなく、「APIのP95応答時間は100ms未満であるべき」のように、検証可能で具体的な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。例えば、「我々はスループットよりもデータ一貫性を優先する。なぜなら金融取引を扱うからだ」のように記述します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述するように促します。これにより、将来状況が変化した際に、より柔軟で適切な判断を下すことが可能になります。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいライブラリの導入、主要コンポーネントの責務変更）は、必ずこの憲章の更新とセットでレビューします。

*   **リスク:** 全体原則と、局所的な要求が衝突する。
    *   **対策:** 原則として、この憲章の記述を優先します。ただし、局所的なコード内コメントで、逸脱する明確な理由とそれが戦術的な判断であることが示されている場合に限り、限定的な逸脱を許容します。

---

## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

本ライブラリ固有の原則を定義します。ルートの原則にも準拠します。

*   **原則1: データコピー処理の外部注入 (Dependency Injection)**
    *   **判断:** メモリコピー処理（読み出し/書き込み）を関数ポインタとして外部から受け取る設計とする。
    *   **理由:** DMA転送などのハードウェア固有の最適化を、ライブラリ本体を変更することなく適用可能にするため。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

該当なし (N/A)

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

このセクションは、AIがどう振る舞うべきかの指針を記述するセクションです。

*   **未知の問題への対処:**
    *   この憲章に記載されていないアーキテクチャ上の問題に直面した際、AIはプロジェクトの「核となる原則」に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰ぐこと。

*   **戦略（憲章）と戦術（コメント）の連携:**
    *   AIは、この憲章（戦略）とコード内のインテント・コメント（戦術）が一貫性を保つように支援する。コード生成やリファクタリングの提案は、常に両者と整合性が取れていなければならない。

### 4. コンポーネント設計仕様 (Component Design Specifications)

#### 4.1. リングバッファライブラリ (Ring Buffer Library)

- **責務 (Responsibility):**
    - 固定サイズのメモリ領域をリングバッファとして管理し、バイトストリームの効率的かつ安全な書き込み・読み出し機能を提供する。
    - データコピー処理（読み書き）を外部から注入（Dependency Injection）可能にすることで、ハードウェア（DMA等）への最適化を可能にする。注入されない場合は、自前実装の標準的なメモリコピー機能を提供する。
    - 割り込みコンテキストと通常タスクコンテキストの両方から安全に呼び出せる（リエントラントな）関数設計を目指す。ただし、複数タスク/割り込みからの同時アクセスにおける排他制御は、ライブラリの利用者側の責任範囲とする。

- **提供するAPI (Public API):**
    - `typedef void (*rb_copy_func_t)(void* dest, const void* src, size_t len);`
    - `rb_bool rb_init(rb_handle_t handle, void* buffer, rb_size_t size, rb_bool overwrite_on_full, rb_copy_func_t read_func, rb_copy_func_t write_func)`:
        - **責務:** 提供されたメモリ領域(`buffer`)とサイズ(`size`)を使い、提供されたハンドル(`handle`)が指す構造体を初期化する。
        - `handle`: 初期化対象の `ring_buffer_t` 構造体へのポインタ。
        - `buffer`: リングバッファとして使用するメモリ領域へのポインタ。このポインタの管理責任は呼び出し元にある。
        - `size`: バッファのサイズ（バイト単位）。
        - `overwrite_on_full`: `RB_TRUE`の場合、バッファが満杯の時に古いデータを上書きする。`RB_FALSE`の場合は書き込みを失敗させる。
        - `read_func`, `write_func`: データコピー用の関数ポインタ。`NULL`が指定された場合、ライブラリ内部のデフォルト実装が使用される。
        - **戻り値:** 初期化に成功した場合は `RB_TRUE`、失敗した場合は `RB_FALSE` を返す。

    - `size_t rb_write(rb_handle_t handle, const void* data, size_t length)`:
        - **責務:** `init`時に指定された`write_func`またはデフォルト実装を使い、指定されたデータをリングバッファに書き込む。
        - **戻り値:** 実際に書き込めたバイト数を返す。バッファが満杯で書き込めなかった場合、`overwrite_on_full`が`false`なら0を返す。`overwrite_on_full`が`true`の場合は、要求された`length`を返す（古いデータは上書きされる）。

    - `size_t rb_read(rb_handle_t handle, void* buffer, size_t length)`:
        - **責務:** `init`時に指定された`read_func`またはデフォルト実装を使い、リングバッファからデータを読み出し、指定された`buffer`に格納する。読み出されたデータはバッファから削除される。
        - **戻り値:** 実際に読み出せたバイト数を返す。

    - `size_t rb_peek(rb_handle_t handle, void* buffer, size_t length)`:
        - **責務:** リングバッファからデータを読み出すが、バッファからは削除しない（読み出し位置は変更されない）。データコピーには`init`時に指定された`read_func`またはデフォルト実装が使われる。
        - **戻り値:** 実際に読み出せた（覗き見できた）バイト数を返す。

    - `size_t rb_get_free_space(rb_handle_t handle)`:
        - **責務:** バッファの空き容量をバイト単位で返す。
        - **戻り値:** 空きバイト数。

    - `size_t rb_get_used_space(rb_handle_t handle)`:
        - **責務:** バッファ内で使用されているデータ量をバイト単位で返す。
        - **戻り値:** 使用中のバイト数。

- **主要なデータ構造 (Key Data Structures):**
    - `ring_buffer_t` (ハンドルとして利用者に返される構造体):
        - `uint8_t* buffer`: ユーザーから提供されたバッファ領域へのポインタ。
        - `size_t size`: バッファの総サイズ。
        - `size_t head`: 書き込み位置（次に書き込むべきインデックス）。
        - `size_t tail`: 読み出し位置（次に読み出すべきインデックス）。
        - `bool is_full`: バッファが満杯かどうかを示すフラグ (`head == tail` の状態が空か満杯かを区別するために使用)。
        - `bool overwrite_on_full`: 満杯時の上書き許可フラグ。
        - `rb_copy_func_t read_from_ring`: 読み出し時に使用するデータコピー関数。
        - `rb_copy_func_t write_to_ring`: 書き込み時に使用するデータコピー関数。

- **状態とライフサイクル (State and Lifecycle):**
    - **Uninitialized:** `rb_init`が呼び出される前の状態。
    - **Empty:** バッファにデータがない状態 (`head == tail` かつ `is_full == false`)。
    - **Normal:** データが一部入っている状態。
    - **Full:** バッファが満杯の状態 (`head == tail` かつ `is_full == true`)。

- **重要なアルゴリズム (Key Algorithms):**
    - **データコピー:** `read_from_ring` / `write_to_ring` の関数ポインタ経由で実処理を呼び出す。ポインタが`NULL`の場合は、自前実装のバイト単位ループによるコピー処理を呼び出す。
    - **インデックスのラップアラウンド:** `head`および`tail`ポインタは、バッファの終端に達した場合、モジュロ演算（`% size`）または同等の比較処理によって0に戻る。パフォーマンスを重視し、`if (index >= size) index = 0;` のような分岐を基本とする。
    - **空き/使用容量の計算:** `head`と`tail`の位置関係から計算する。`head >= tail`の場合と`head < tail`（ラップアラウンド発生後）の場合で計算方法が異なる。
    - **上書き処理 (`overwrite_on_full == true`):** 書き込み要求時にバッファが満杯だった場合、書き込むデータ長に応じて`tail`（読み出しポインタ）も進めることで、古いデータを捨てる。

### 5. テストと検証 (Testing and Verification)

該当なし (N/A)