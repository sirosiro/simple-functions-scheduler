# アーキテクチャ憲章 (ARCHITECTURE_MANIFEST.md)

---

## Part 1: このマニフェストの取扱説明書 (Guide)

このパートには、マニフェストの思想、目的、書き方を定義するガイドを含めてください。ドキュメントの冒頭に配置し、編集者はまずここを読むように促す構成とします。

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

*   **役割:** この憲章は、プロジェクトの「北極星」として、開発者とAIが共有する高レベルな目標と譲れない制約を定義します。
*   **期待する効果:** これにより、AIは単なるコード生成を超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能になります。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。** 「高速であるべき」ではなく、「APIのP95応答時間は100ms未満」のように、検証可能な目標を設定します。
*   **原則2: 「なぜ」に焦点を当てる。** ルールだけではなく、その背景にあるトレードオフの判断（例：「我々はスループットよりもデータ一貫性を優先する。なぜなら金融取引を扱うからだ」）を明記します。これが形骸化を防ぎ、将来の変更を助けます。
*   **原則3: 「禁止」ではなく「判断の背景」を記述する。** 「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述するように促します。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化する。
    *   **対策:** アーキテクチャに影響を与えるコード変更は、必ずこの憲章の更新とセットでレビューします。
*   **リスク:** 全体原則と局所的な要求が衝突する。
    *   **対策:** 原則として憲章を優先します。ただし、局所的なコード内コメントで明確な理由が示されている場合に限り、戦術的な逸脱を許容します。

---

## Part 2: マニフェスト本体 (Content)

このパートは、エンジニアがプロジェクトの進化に合わせて継続的に編集・追記する、生きた記録です。

### 1. 核となる原則 (Core Principles)

このセクションは、プロジェクトの不変的なルールを「なぜ」の理由付けと共に定義するセクションです。

*   **原則1: 予測可能性とリソース効率性の最優先**
    *   **理由:** 本システムはリソースが限られた組み込み環境での動作を想定しているため、動的なメモリ割り当てを避け、静的なリソース管理を徹底する。これにより、メモリ使用量と実行時間を予測可能にし、システムの安定性を保証する。
*   **原則2: 協調的マルチタスクによるシンプルさの維持**
    *   **理由:** プリエンプティブなスケジューラがもたらす複雑さを避け、タスクが自発的に制御を解放する協調的モデルを採用する。これにより、タスクの実行順序が明確になり、デバッグと保守が容易になる。
*   **原則3: 時間測定の正確性と原子性の保証**
    *   **理由:** リアルタイム制御の基盤として、タイマー機能はカウンタのロールオーバーを正確に処理し、割り込み安全なアクセスを保証しなければならない。これは、時間依存の処理における信頼性の根幹である。
*   **原則4: 自己完結性と移植性**
    *   **理由:** 標準ライブラリへの依存を最小限に抑え、必要な機能（例: `strncpy`）を内部で提供することで、異なるプラットフォームへの移植性を高める。
        <!-- ここに新たな原則を追記 -->

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

このセクションは、「なぜこの構造になったのか」を後から追えるように、重要な設計判断をログとして残すセクションです。

<!--
### [日付]
- **関連する核となる原則:** (例: 原則1: 予測可能性とリソース効率性の最優先)
- **決定事項:**
- **判断理由:**
- **検討された他の選択肢:**
- **決定による影響:**
-->

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

このセクションは、AIがどう振る舞うべきかの指針を記述するセクションです。

*   **未知の問題への対処:** この憲章にない問題に直面した際、AIは核となる原則に立ち返り、複数の選択肢とそのトレードオフを提示し、人間の判断を仰ぐこと。
*   **戦略（憲章）と戦術（コメント）の連携:** この憲章（戦略）とコード内コメント（戦術）は、常に一貫性を保つべきである。

### 4. コンポーネント設計仕様 (Component Design Specifications)

このセクションは、本マニフェストを元に、AIが人間と協調して機能的に同等なコードを再実装できるように、システムの主要コンポーネントの「設計仕様」を定義するセクションです。

#### 4.1. SFS (Simple Function Scheduler) モジュール

-   **責務 (Responsibility):**
    *   固定数のタスク制御ブロック (TCB) を管理し、タスクの生成、実行、終了、変更を協調的マルチタスクモデルで提供する。
    *   タスクを優先度 `order` に基づいて実行待ちリストに登録し、その順序でディスパッチする。
    *   タスクが共有可能なワークバッファを提供し、タスク間でデータを交換できるようにする。

-   **提供するAPI (Public API):**
    *   `short SFS_initialize(void)`:
        *   責務: スケジューラの内部状態とタスク制御ブロックのプールを初期化する。
        *   戻り値: `0` (成功)。
    *   `short SFS_dispatch(void)`:
        *   責務: 現在のアクティブタスクリストを順番に実行する。各タスクは自身が制御を返却するまで実行される。
        *   戻り値: `実行されたタスクの数`。
    *   `short SFS_fork(char *name, short order, void (*entry_point)(void))`:
        *   責務: 新しいタスクを生成し、フリーリストからTCBを取得して初期化し、`order` に基づいて実行待ちリストに挿入する。
        *   `name`: タスク名。関数内でコピーして使用するため、呼び出し元は自身のポインタ管理責任を持つ。
        *   `order`: タスクの優先度。数値が小さいほど高優先度。
        *   `entry_point`: タスクのメイン処理を行う関数へのポインタ。
        *   戻り値: `0` (成功), `-1` (タスク制御ブロックの割り当て失敗)。
    *   `void *SFS_work(void)`:
        *   責務: 現在実行中のタスクに割り当てられた汎用ワークバッファへのポインタを返す。
        *   戻り値: `void*` (現在のタスクの `work` バッファへのポインタ)。
    *   `void *SFS_otherWork(char *name)`:
        *   責務: 指定された名前のタスクに割り当てられた汎用ワークバッファへのポインタを返す。
        *   `name`: ワークバッファを取得したいタスクの名前。
        *   戻り値: `void*` (指定タスクの `work` バッファへのポインタ), `NULL` (タスクが見つからない場合)。
    *   `short SFS_kill(void)`:
        *   責務: 現在実行中のタスクを終了処理に移行させる。実際の削除は `SFS_dispatch` の次のサイクルで行われる。
        *   戻り値: `0` (成功)。
    *   `short SFS_change(char *name, short order, void (*entry_point)(void))`:
        *   責務: 現在実行中のタスクの名前、優先度、エントリポイントを変更する。
        *   `name`: 新しいタスク名。
        *   `order`: 新しい優先度。
        *   `entry_point`: 新しいタスクのエントリポイント。
        *   戻り値: `0` (成功)。

-   **主要なデータ構造 (Key Data Structures):**
    *   `struct SFS_tg`:
        ```c
        struct SFS_tg {
          char name[SFS_NAME_SIZE];      // タスク名 (固定長)
          unsigned short order;          // 実行優先度 (小さいほど高優先度)
          struct SFS_tg *pFront;       // 実行待ちリストの前のタスクへのポインタ (双方向リスト用)
          struct SFS_tg *pBack;        // 実行待ちリストの次のタスクへのポインタ (双方向リスト用)
          void (*pFunction)(void);       // タスクのエントリポイント関数ポインタ
          char work[SFS_WORK_SIZE];      // タスク固有の汎用ワークバッファ
        };
        ```
    *   `static struct SFS_tg SFS[BODY]`: 全タスク制御ブロックを保持する固定長配列。
    *   `static struct SFS_tg *pTask`: 実行待ちのアクティブなタスクリストのヘッドポインタ。`order` に基づいてソートされた双方向連結リスト。
    *   `static struct SFS_tg *pPool`: 利用可能なタスク制御ブロックのフリーリストのヘッドポインタ。単方向連結リスト。

-   **状態とライフサイクル (State and Lifecycle):**
    *   **TCBの状態:**
        *   `Pooled`: `pPool` リストに存在し、利用可能な状態。
        *   `Active`: `pTask` リストに存在し、実行待ちまたは実行中の状態。
        *   `Killed`: `SFS_kill` により `pFunction` が `SFS_giveup` に置き換えられた状態。`SFS_dispatch` で実行された後 `Pooled` に戻る。
    *   **スケジューラのライフサイクル:** `SFS_initialize` で初期化され、`SFS_dispatch` をループで呼び出すことでタスクが実行される。タスクは `SFS_fork` で追加され、`SFS_kill` で論理的に削除、`SFS_giveup` で物理的に削除される。

-   **重要なアルゴリズム (Key Algorithms):**
    *   **タスク登録 (`SFS_regist`):** タスクの `order` に基づくソート済み挿入。ヘッド、テール、中間への挿入を双方向リンクリストで処理。
    *   **タスク解放 (`SFS_giveup`):** 双方向リンクリストからの要素削除。ヘッド、テール、中間からの削除を処理し、フリーリスト (`pPool`) に戻す。

#### 4.2. FRCC (Free Run Clock Counter) モジュール

-   **責務 (Responsibility):**
    *   ハードウェア（外部）によって周期的にインクリメントされるフリーランカウンタ（8ビット版と32ビット版）を提供する。
    *   カウンタのロールオーバーを考慮した正確な時間差計算機能を提供する。
    *   フリーランカウンタへの割り込み安全なアクセスを保証する。
    *   ワンショットまたは繰り返し可能な時間経過チェック機能を提供する。

-   **提供するAPI (Public API):**
    *   `unsigned char GetFreeRunGapMini(unsigned char vPastCount)`:
        *   責務: 8ビットフリーランカウンタ `gFreeRunCounterMini` と過去の値 `vPastCount` との間の時間差を計算する。カウンタのロールオーバーを考慮する。
        *   `vPastCount`: 過去のカウンタ値。
        *   戻り値: `unsigned char` (経過時間)。
    *   `void FRCInterrupt(void (*di)(void), void (*ei)(void))`:
        *   責務: フリーランカウンタへの原子的なアクセスを保証するために使用される、割り込み禁止/許可関数を登録する。
        *   `di`: 割り込み禁止関数へのポインタ。
        *   `ei`: 割り込み許可関数へのポインタ。
    *   `unsigned long GetFreeRunCounter(void)`:
        *   責務: 現在の32ビットフリーランカウンタ `gFreeRunCounter` の値を割り込み安全に取得する。
        *   戻り値: `unsigned long` (現在のカウンタ値)。
    *   `unsigned long GetFreeRunGap(unsigned long vFarstCount, unsigned long vSecondCount)`:
        *   責務: 2つの32ビットカウンタ値間の時間差を計算する。カウンタのロールオーバーを考慮する。
        *   `vFarstCount`: 開始カウンタ値。
        *   `vSecondCount`: 終了カウンタ値。
        *   戻り値: `unsigned long` (経過時間)。
    *   `void FRCGapCheckStart(FRC *vGapChk, unsigned long vStopGap)`:
        *   責務: 時間経過チェック用の `FRC` 構造体を初期化する。現在のカウンタ値を `StartPoint` として記録し、目標経過時間 `vStopGap` を設定する。
        *   `vGapChk`: 初期化する `FRC` 構造体へのポインタ。
        *   `vStopGap`: チェックする時間間隔。
    *   `unsigned long FRCGapCheck(FRC *vGapChk)`:
        *   責務: `FRCGapCheckStart` で設定された時間間隔が経過したかをチェックする。
        *   `vGapChk`: チェックする `FRC` 構造体へのポインタ。
        *   戻り値: `0` (時間経過済み), `それ以外の値` (残り時間)。
    *   `void FRCGapCheckStop(FRC *vGapChk)`:
        *   責務: `FRC` 構造体の時間経過チェックを停止し、無効化する。
        *   `vGapChk`: 停止する `FRC` 構造体へのポインタ。

-   **主要なデータ構造 (Key Data Structures):**
    *   `unsigned char gFreeRunCounterMini`: 8ビットフリーランカウンタ（グローバル変数）。
    *   `unsigned long gFreeRunCounter`: 32ビットフリーランカウンタ（グローバル変数）。
    *   `struct FRCGapChk_tg`:
        ```c
        typedef struct FRCGapChk_tg {
          char OneShot;          // 0: 経過済み, 1: 監視中, -1: 未使用/停止
          unsigned long StartPoint;   // 測定開始時のFreeRunCounter値
          unsigned long StopGap;      // 監視する時間間隔
        }FRC;
        ```
    *   `static void (*_di)(void)`: 割り込み禁止関数への内部ポインタ。
    *   `static void (*_ei)(void)`: 割り込み許可関数への内部ポインタ。

-   **状態とライフサイクル (State and Lifecycle):**
    *   `FRC` 構造体の `OneShot` メンバにより、タイマーの状態が管理される。
    *   `OneShot = 1`: 監視中。
    *   `OneShot = 0`: 時間経過済み（ワンショット）。
    *   `OneShot = -1`: 未使用または停止状態。

-   **重要なアルゴリズム (Key Algorithms):**
    *   **カウンタロールオーバー対応の時間差計算:**
        *   `if (iNowCount >= vPastCount) { return iNowCount - vPastCount; } else { return ((型)-1)-vPastCount+iNowCount; }`
        *   これにより、カウンタが最大値から0にロールオーバーした場合でも正確な時間差を計算できる。
    *   **原子的なカウンタ読み出し:** 登録された割り込み禁止/許可関数 (`_di`, `_ei`) を利用して、グローバルカウンタの読み出し中に割り込みが発生しないことを保証する。

<!--
### 4.x. (新規コンポーネント名)
- **責務 (Responsibility):** (このコンポーネントがシステム全体に対して負うべき、単一の責任)
- **提供するAPI (Public API):**
- **主要なデータ構造 (Key Data Structures):**
- **状態とライフサイクル (State and Lifecycle):**
- **重要なアルゴリズム (Key Algorithms):**
-->
