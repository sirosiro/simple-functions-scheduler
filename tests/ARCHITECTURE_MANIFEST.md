# テスト・サンプル アーキテクチャ憲章 (Architecture Manifest)

---

## Part 1: このマニフェストの取扱説明書 (Guide)

このパートは、このマニフェストの思想、目的、そして書き方を定義するガイドです。このドキュメントを編集する際は、まずここを読んでください。

### 1. 目的 (Purpose): なぜこの憲章が存在するのか

*   **役割:** この憲章は、プロジェクトの「北極星」です。開発者とAIが共有する高レベルな目標と、譲れない制約を定義します。これは、日々のコーディングにおける判断の拠り所となります。
*   **期待する効果:** これにより、AIは単なるコード生成を超え、アーキテクチャ全体と一貫した、より洞察に富んだ提案が可能になります。人間は、設計判断の背景を素早く理解し、一貫性を保った開発を継続できます。

### 2. 憲章の書き方 (Guidelines)

*   **原則1: 具体的に記述する。**
    *   「高速であるべき」のような曖昧な表現ではなく、「APIのP95応答時間は100ms未満であるべき」のように、検証可能で具体的な目標を設定します。

*   **原則2: 「なぜ」に焦点を当てる。**
    *   ルールだけではなく、その背景にあるトレードオフの判断を明記します。例えば、「我々はスループットよりもデータ一貫性を優先する。なぜなら金融取引を扱うからだ」のように記述します。これが憲章の形骸化を防ぎ、将来の変更を助けます。

*   **原則3: 「禁止」ではなく「判断の背景」を記述する。**
    *   「禁止事項」や「守るべきルール」といった思考停止を招く言葉を避け、「我々はこういう判断をした」といった形で、判断に至った文脈や背景そのものを記述するように促します。これにより、将来状況が変化した際に、より柔軟で適切な判断を下すことが可能になります。

### 3. リスクと対策 (Risks and Mitigations)

*   **リスク:** ドキュメントが陳腐化し、現実のコードと乖離する。
    *   **対策:** アーキテクチャに影響を与えるコード変更（例: 新しいライブラリの導入、主要コンポーネントの責務変更）は、必ずこの憲章の更新とセットでレビューします。

*   **リスク:** 全体原則と、局所的な要求が衝突する。
    *   **対策:** 原則として、この憲章の記述を優先します。ただし、局所的なコード内コメントで、逸脱する明確な理由とそれが戦術的な判断であることが示されている場合に限り、限定的な逸脱を許容します。

---

## Part 2: マニフェスト本体 (Content)

### 1. 核となる原則 (Core Principles)

本テストスイート固有の原則を定義します。ルートの原則にも準拠します。

*   **原則1: 自動化された検証**
    *   **判断:** すべてのサンプルは、実行時に自身の動作結果を出力し、人間またはスクリプトが正否を判断できる形式とする。
    *   **理由:** 手動確認の手間を減らし、継続的なインテグレーションを容易にするため。

*   **原則2: 実例としてのドキュメント**
    *   **判断:** 各サンプルファイルは、特定の機能やユースケース（例: 基本的なタスクスケジューリング、優先度変更、FIFOの境界値動作など）に焦点を当てた「実行可能なドキュメント」としての役割を果たす。
    *   **理由:** 静的なドキュメントよりも、動作するコードの方が信頼性が高く、理解しやすいため。

### 2. 主要なアーキテクチャ決定の記録 (Key Architectural Decisions)

該当なし (N/A)

### 3. AIとの協調に関する指針 (AI Collaboration Policy)

このセクションは、AIがどう振る舞うべきかの指針を記述するセクションです。

*   **未知の問題への対処:**
    *   この憲章に記載されていないアーキテクチャ上の問題に直面した際、AIはプロジェクトの「核となる原則」に立ち返り、複数の選択肢とそれぞれのトレードオフを提示し、人間の判断を仰ぐこと。

*   **戦略（憲章）と戦術（コメント）の連携:**
    *   AIは、この憲章（戦略）とコード内のインテント・コメント（戦術）が一貫性を保つように支援する。コード生成やリファクタリングの提案は、常に両者と整合性が取れていなければならない。

### 4. コンポーネント設計仕様 (Component Design Specifications)

該当なし (N/A) - 本ディレクトリはテストコードであり、コンポーネント実装ではないため。

### 5. テストと検証 (Testing and Verification)

#### 5.1. SFS 機能テスト
*   **tests/sample00.c**: 基本的なタスク生成 (`fork`) とディスパッチの動作確認。
*   **tests/sample01.c**: タスクスイッチングと基本的な並行動作の確認。
*   **tests/sample02.c**: 優先度 (`order`) に基づくスケジューリング順序の検証。
*   **tests/sample03.c**: タスク間通信と協調動作の検証。
*   **tests/sample_frcc01.c**: FRCC (Free Run Clock Counter) を用いた時間管理と擬似タイマー動作の検証。

#### 5.2. ライブラリ単体テスト
*   **tests/sample04.c**: FIFO ライブラリの境界値テスト（満杯時のプッシュ、空時のポップなど）。
*   **tests/sample05.c**: リングバッファライブラリの読み書き、ラップアラウンド、上書き設定の挙動検証。

#### 5.3. テスト実行方針 (Testing Strategy)
*   `make all` コマンドにより、すべてのテストプログラムがコンパイルされ、順次実行される。
*   各プログラムは、正常終了時には終了コード 0 を返し、異常時には非 0 を返す（またはエラーメッセージを出力して終了する）よう実装されるべきである。
*   新機能の実装やバグ修正時は、既存のテストがパスすることを確認し（回帰テスト）、必要に応じて新たなテストケースを追加する。